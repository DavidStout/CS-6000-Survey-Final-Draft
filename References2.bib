
@inproceedings{gopstein_understanding_2017,
	address = {Paderborn, Germany},
	title = {Understanding misunderstandings in source code},
	isbn = {978-1-4503-5105-8},
	url = {http://dl.acm.org/citation.cfm?doid=3106237.3106264},
	doi = {10.1145/3106237.3106264},
	abstract = {Humans often mistake the meaning of source code, and so misjudge a program’s true behavior. These mistakes can be caused by extremely small, isolated patterns in code, which can lead to signiicant runtime errors. These patterns are used in large, popular software projects and even recommended in style guides. To identify code patterns that may confuse programmers we extracted a preliminary set of ‘atoms of confusion’ from known confusing code. We show empirically in an experiment with 73 participants that these code patterns can lead to a signiicantly increased rate of misunderstanding versus equivalent code without the patterns. We then go on to take larger confusing programs and measure (in an experiment with 43 participants) the impact, in terms of programmer confusion, of removing these confusing patterns. All of our instruments, analysis code, and data are publicly available online for replication, experimentation, and feedback.},
	language = {en},
	urldate = {2018-09-07},
	booktitle = {Proceedings of the 2017 11th {Joint} {Meeting} on {Foundations} of {Software} {Engineering}  - {ESEC}/{FSE} 2017},
	publisher = {ACM Press},
	author = {Gopstein, Dan and Iannacone, Jake and Yan, Yu and DeLong, Lois and Zhuang, Yanyan and Yeh, Martin K.-C. and Cappos, Justin},
	year = {2017},
	pages = {129--139},
	annote = {Browse Time: 1 min 57 sec, Scan; Authors are individuals that I currently work with and paper is directly in my field of interest/research.
 
Scan notes: This theoretical/experimental paper looks to address the problem of confusing code in style guides that propagated to bugs in production code. The solution that is presented is that the confusing code (atoms) can be identified and future style guides and standards may be written with the non-confusing patterns instead. The significance of this experiment is high, given that many atoms were found that were commonly used in production code and can be identified to be removed for ease of program intent.
 
Critical read. },
	file = {Gopstein et al. - 2017 - Understanding misunderstandings in source code.pdf:C\:\\Users\\Charles\\Zotero\\storage\\TAZKUC6C\\Gopstein et al. - 2017 - Understanding misunderstandings in source code.pdf:application/pdf}
}

@inproceedings{siegmund_measuring_2017,
	address = {Paderborn, Germany},
	title = {Measuring neural efficiency of program comprehension},
	isbn = {978-1-4503-5105-8},
	url = {http://dl.acm.org/citation.cfm?doid=3106237.3106268},
	doi = {10.1145/3106237.3106268},
	abstract = {Most modern software programs cannot be understood in their entirety by a single programmer. Instead, programmers must rely on a set of cognitive processes that aid in seeking, filtering, and shaping relevant information for a given programming task. Several theories have been proposed to explain these processes, such as “beacons,” for locating relevant code, and “plans,” for encoding cognitive models. However, these theories are decades old and lack validation with modern cognitive-neuroscience methods. In this paper, we report on a study using functional magnetic resonance imaging (fMRI) with 11 participants who performed program comprehension tasks. We manipulated experimental conditions related to beacons and layout to isolate specific cognitive processes related to bottom-up comprehension and comprehension based on semantic cues. We found evidence of semantic chunking during bottom-up comprehension and lower activation of brain areas during comprehension based on semantic cues, confirming that beacons ease comprehension.},
	language = {en},
	urldate = {2018-09-07},
	booktitle = {Proceedings of the 2017 11th {Joint} {Meeting} on {Foundations} of {Software} {Engineering}  - {ESEC}/{FSE} 2017},
	publisher = {ACM Press},
	author = {Siegmund, Janet and Peitek, Norman and Parnin, Chris and Apel, Sven and Hofmeister, Johannes and Kästner, Christian and Begel, Andrew and Bethmann, Anja and Brechmann, André},
	year = {2017},
	pages = {140--150},
	annote = {Browse Time: 2mins 8sec, Scan; Interesting concept and possible link to future research in cognitive code confusion.
Scan notes: This theoretical/experimental paper confirms the previous findings of other authors that semantic cues in programming is a more efficient process for understanding source code than bottom-up comprehension. The fMRI readings that resulted from this experiment are in holding with the previous researchers and shows that it is a useful measurement tool for CS research. The significance is enough to allow further study into the activation of areas of the brain with certain cues, beacons, and techniques of program layout.
 
Critical read needed.},
	file = {Siegmund et al. - 2017 - Measuring neural efficiency of program comprehensi.pdf:C\:\\Users\\Charles\\Zotero\\storage\\5JXFL3LQ\\Siegmund et al. - 2017 - Measuring neural efficiency of program comprehensi.pdf:application/pdf}
}

@inproceedings{ceccato_effectiveness_2009,
	title = {The effectiveness of source code obfuscation: {An} experimental assessment},
	shorttitle = {The effectiveness of source code obfuscation},
	doi = {10.1109/ICPC.2009.5090041},
	abstract = {Source code obfuscation is a protection mechanism widely used to limit the possibility of malicious reverse engineering or attack activities on a software system. Although several code obfuscation techniques and tools are available, little knowledge is available about the capability of obfuscation to reduce attackers' efficiency, and the contexts in which such an efficiency may vary. This paper reports the outcome of two controlled experiments meant to measure the ability of subjects to understand and modify decompiled, obfuscated Java code, compared to decompiled, clear code. Results quantify to what extent code obfuscation is able to make attacks more difficult to be performed, and reveal that obfuscation can mitigate the effect of factors that can alter the likelihood of a successful attack, such as the attackers' skill and experience, or the intrinsic characteristics of the system under attack.},
	booktitle = {2009 {IEEE} 17th {International} {Conference} on {Program} {Comprehension}},
	author = {Ceccato, M. and Penta, M. Di and Nagra, J. and Falcarin, P. and Ricca, F. and Torchiano, M. and Tonella, P.},
	month = may,
	year = {2009},
	keywords = {Java, Software systems, Application software, Automatic control, Data structures, Empirical studies, Encoding, Java code, Performance analysis, Program comprehension, Protection, protection mechanism, Reverse engineering, security of data, Software measurement, Software Obfuscation, software protection, software system, source code obfuscation techniques},
	pages = {178--187},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\Charles\\Zotero\\storage\\HULBFE59\\5090041.html:text/html;IEEE Xplore Full Text PDF:C\:\\Users\\Charles\\Zotero\\storage\\KIEB24IY\\Ceccato et al. - 2009 - The effectiveness of source code obfuscation An e.pdf:application/pdf}
}

@inproceedings{anckaert_program_2007,
	address = {Alexandria, Virginia, USA},
	title = {Program obfuscation: a quantitative approach},
	isbn = {978-1-59593-885-5},
	shorttitle = {Program obfuscation},
	url = {http://portal.acm.org/citation.cfm?doid=1314257.1314263},
	doi = {10.1145/1314257.1314263},
	abstract = {Despite the recent advances in the theory underlying obfuscation, there still is a need to evaluate the quality of practical obfuscating transformations more quickly and easily. This paper presents the ﬁrst steps toward a comprehensive evaluation suite consisting of a number of deobfuscating transformations and complexity metrics that can be readily applied on existing and future transformations in the domain of binary obfuscation. In particular, a framework based on software complexity metrics measuring four program properties: code, control ﬂow, data and data ﬂow is suggested. A number of well-known obfuscating and deobfuscating transformations are evaluated based upon their impact on a set of complexity metrics. This enables us to quantitatively evaluate the potency of the (de)obfuscating transformations.},
	language = {en},
	urldate = {2018-09-25},
	booktitle = {Proceedings of the 2007 {ACM} workshop on {Quality} of protection  - {QoP} '07},
	publisher = {ACM Press},
	author = {Anckaert, Bertrand and Madou, Matias and De Sutter, Bjorn and De Bus, Bruno and De Bosschere, Koen and Preneel, Bart},
	year = {2007},
	pages = {15},
	file = {Anckaert et al. - 2007 - Program obfuscation a quantitative approach.pdf:C\:\\Users\\Charles\\Zotero\\storage\\4ZPY7LNQ\\Anckaert et al. - 2007 - Program obfuscation a quantitative approach.pdf:application/pdf}
}

@inproceedings{capiluppi_code_2012,
	title = {Code {Defactoring}: {Evaluating} the {Effectiveness} of {Java} {Obfuscations}},
	shorttitle = {Code {Defactoring}},
	doi = {10.1109/WCRE.2012.17},
	abstract = {Obfuscation is a very common protection against reverse engineering attacks: it modifies a program structure to make it harder for the adversary to analyse and understand it. Conceptually, obfuscation is the opposite of refactoring: the code should be more complex to understand, bloated, and with excessive characteristics from the design point of view. This paper aims at evaluating the code complexity introduced by different obfuscation algorithms by using software engineering metrics. Using structural metrics, this paper illustrates how the various types of obfuscation algorithms perform in terms of OO attributes that should be kept low in refactoring. Results show that the majority of the selected algorithms produce no changes in the structural attributes or the average complexity, but they produce more “dead” code. We argue that this could not represent the optimal way to protect the code: when protecting against reverse engineering attacks, a preference should be given to those algorithms that increase the complexity and alter the structural metrics.},
	booktitle = {2012 19th {Working} {Conference} on {Reverse} {Engineering}},
	author = {Capiluppi, A. and Falcarin, P. and Boldyreff, C.},
	month = oct,
	year = {2012},
	keywords = {Java, Software, software maintenance, Measurement, Software algorithms, reverse engineering, Arrays, code complexity, code defactoring, Complexity theory, computer crime, cyclomatic complexity, dead code, Java obfuscations, obfuscation, OO attributes, program structure modification, reverse engineering attack, security metrics, software engineering metrics, software metrics, Software protection, structural attributes, structural metrics},
	pages = {71--80},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\Charles\\Zotero\\storage\\K8U5XRHR\\6385103.html:text/html;IEEE Xplore Full Text PDF:C\:\\Users\\Charles\\Zotero\\storage\\CMEVYAXN\\Capiluppi et al. - 2012 - Code Defactoring Evaluating the Effectiveness of .pdf:application/pdf}
}

@inproceedings{haiduc_supporting_2010,
	address = {Cape Town, South Africa},
	title = {Supporting program comprehension with source code summarization},
	volume = {2},
	isbn = {978-1-60558-719-6},
	url = {http://portal.acm.org/citation.cfm?doid=1810295.1810335},
	doi = {10.1145/1810295.1810335},
	abstract = {One of the main challenges faced by today’s developers is keeping up with the staggering amount of source code that needs to be read and understood. In order to help developers with this problem and reduce the costs associated with it, one solution is to use simple textual descriptions of source code entities that developers can grasp easily, while capturing the code semantics precisely. We propose an approach to automatically determine such descriptions, based on automated text summarization technology.},
	language = {en},
	urldate = {2018-09-26},
	booktitle = {Proceedings of the 32nd {ACM}/{IEEE} {International} {Conference} on {Software} {Engineering} - {ICSE} '10},
	publisher = {ACM Press},
	author = {Haiduc, Sonia and Aponte, Jairo and Marcus, Andrian},
	year = {2010},
	pages = {223},
	file = {Haiduc et al. - 2010 - Supporting program comprehension with source code .pdf:C\:\\Users\\Charles\\Zotero\\storage\\6RSU9AVU\\Haiduc et al. - 2010 - Supporting program comprehension with source code .pdf:application/pdf}
}

@inproceedings{gopstein_prevalence_2018,
	address = {Gothenburg, Sweden},
	title = {Prevalence of confusing code in software projects: atoms of confusion in the wild},
	isbn = {978-1-4503-5716-6},
	shorttitle = {Prevalence of confusing code in software projects},
	url = {http://dl.acm.org/citation.cfm?doid=3196398.3196432},
	doi = {10.1145/3196398.3196432},
	abstract = {Prior work has shown that extremely small code patterns, such as the conditional operator and implicit type conversion, can cause considerable misunderstanding in programmers. Until now, the real world impact of these patterns ś known as ‘atoms of confusion’ ś was only speculative. This work uses a corpus of 14 of the most popular and inluential open source C and C++ projects to measure the prevalence and signiicance of these small confusing patterns. Our results show that the 15 known types of confusing micro patterns occur millions of times in programs like the Linux kernel and GCC, appearing on average once every 23 lines. We show there is a strong correlation between these confusing patterns and bug-ix commits as well as a tendency for confusing patterns to be commented. We also explore patterns at the project level showing the rate of security vulnerabilities is higher in projects with more atoms. Finally, we examine real code examples containing these atoms, including ones that were used to ind and ix bugs in our corpus. In total this work demonstrates that beyond simple misunderstanding in the lab setting, atoms of confusion are both prevalent ś occurring often in real projects, and meaningful ś being removed by bug-ix commits at an elevated rate.},
	language = {en},
	urldate = {2018-09-26},
	booktitle = {Proceedings of the 15th {International} {Conference} on {Mining} {Software} {Repositories}  - {MSR} '18},
	publisher = {ACM Press},
	author = {Gopstein, Dan and Zhou, Hongwei Henry and Frankl, Phyllis and Cappos, Justin},
	year = {2018},
	pages = {281--291},
	file = {Gopstein et al. - 2018 - Prevalence of confusing code in software projects.pdf:C\:\\Users\\Charles\\Zotero\\storage\\MFG7J9NT\\Gopstein et al. - 2018 - Prevalence of confusing code in software projects.pdf:application/pdf}
}

@inproceedings{yeh_detecting_2017,
	address = {Indianapolis, IN},
	title = {Detecting and comparing brain activity in short program comprehension using {EEG}},
	isbn = {978-1-5090-5920-1},
	url = {http://ieeexplore.ieee.org/document/8190486/},
	doi = {10.1109/FIE.2017.8190486},
	abstract = {Program comprehension is a common task in software development. Programmers perform program comprehension at different stages of the software development life cycle. Detecting when a programmer experiences problems or confusion can be difficult. Self-reported data may be useful, but not reliable. More importantly, it is hard to use the self-reported feedback in real time.},
	language = {en},
	urldate = {2018-09-26},
	booktitle = {2017 {IEEE} {Frontiers} in {Education} {Conference} ({FIE})},
	publisher = {IEEE},
	author = {Yeh, Martin K.-C. and Gopstein, Dan and Yan, Yu and Zhuang, Yanyan},
	month = oct,
	year = {2017},
	pages = {1--5},
	file = {Yeh et al. - 2017 - Detecting and comparing brain activity in short pr.pdf:C\:\\Users\\Charles\\Zotero\\storage\\HY6P9TJI\\Yeh et al. - 2017 - Detecting and comparing brain activity in short pr.pdf:application/pdf}
}

@article{brooks_towards_1983,
	title = {Towards a theory of the comprehension of computer programs},
	volume = {18},
	issn = {00207373},
	url = {http://linkinghub.elsevier.com/retrieve/pii/S0020737383800315},
	doi = {10.1016/S0020-7373(83)80031-5},
	language = {en},
	number = {6},
	urldate = {2018-09-27},
	journal = {International Journal of Man-Machine Studies},
	author = {Brooks, Ruven},
	month = jun,
	year = {1983},
	pages = {543--554},
	file = {Brooks - 1983 - Towards a theory of the comprehension of computer .pdf:C\:\\Users\\Charles\\Zotero\\storage\\ZB5XY5I8\\Brooks - 1983 - Towards a theory of the comprehension of computer .pdf:application/pdf}
}

@article{maalej_comprehension_2014,
	title = {On the {Comprehension} of {Program} {Comprehension}},
	volume = {23},
	issn = {1049331X},
	url = {http://dl.acm.org/citation.cfm?doid=2668018.2622669},
	doi = {10.1145/2622669},
	language = {en},
	number = {4},
	urldate = {2018-09-27},
	journal = {ACM Transactions on Software Engineering and Methodology},
	author = {Maalej, Walid and Tiarks, Rebecca and Roehm, Tobias and Koschke, Rainer},
	month = sep,
	year = {2014},
	pages = {1--37},
	file = {Maalej et al. - 2014 - On the Comprehension of Program Comprehension.pdf:C\:\\Users\\Charles\\Zotero\\storage\\8YPUSHYV\\Maalej et al. - 2014 - On the Comprehension of Program Comprehension.pdf:application/pdf}
}

@inproceedings{roehm_how_2012,
	address = {Zurich},
	title = {How do professional developers comprehend software?},
	isbn = {978-1-4673-1066-6 978-1-4673-1067-3},
	url = {http://ieeexplore.ieee.org/document/6227188/},
	doi = {10.1109/ICSE.2012.6227188},
	abstract = {Research in program comprehension has considerably evolved over the past two decades. However, only little is known about how developers practice program comprehension under time and project pressure, and which methods and tools proposed by researchers are used in industry. This paper reports on an observational study of 28 professional developers from seven companies, investigating how developers comprehend software. In particular we focus on the strategies followed, information needed, and tools used.},
	language = {en},
	urldate = {2018-09-27},
	booktitle = {2012 34th {International} {Conference} on {Software} {Engineering} ({ICSE})},
	publisher = {IEEE},
	author = {Roehm, Tobias and Tiarks, Rebecca and Koschke, Rainer and Maalej, Walid},
	month = jun,
	year = {2012},
	pages = {255--265},
	file = {Roehm et al. - 2012 - How do professional developers comprehend software.pdf:C\:\\Users\\Charles\\Zotero\\storage\\XYM2GXU3\\Roehm et al. - 2012 - How do professional developers comprehend software.pdf:application/pdf}
}

@inproceedings{abbes_empirical_2011,
	title = {An {Empirical} {Study} of the {Impact} of {Two} {Antipatterns}, {Blob} and {Spaghetti} {Code}, on {Program} {Comprehension}},
	doi = {10.1109/CSMR.2011.24},
	abstract = {Antipatterns are "poor" solutions to recurring design problems which are conjectured in the literature to make object-oriented systems harder to maintain. However, little quantitative evidence exists to support this conjecture. We performed an empirical study to investigate whether the occurrence of antipatterns does indeed affect the understandability of systems by developers during comprehension and maintenance tasks. We designed and conducted three experiments, with 24 subjects each, to collect data on the performance of developers on basic tasks related to program comprehension and assessed the impact of two antipatterns and of their combinations: Blob and Spaghetti Code. We measured the developers' performance with: (1) the NASA task load index for their effort, (2) the time that they spent performing their tasks, and, (3) their percentages of correct answers. Collected data show that the occurrence of one antipattern does not significantly decrease developers' performance while the combination of two antipatterns impedes significantly developers. We conclude that developers can cope with one antipattern but that combinations of antipatterns should be avoided possibly through detection and refactorings.},
	booktitle = {2011 15th {European} {Conference} on {Software} {Maintenance} and {Reengineering}},
	author = {Abbes, M. and Khomh, F. and Gueheneuc, Y. and Antoniol, G.},
	month = mar,
	year = {2011},
	keywords = {Java, object-oriented programming, object-oriented systems, software maintenance, program comprehension, Programming, Maintenance engineering, Analysis of variance, antipatterns, Antipatterns, blob, Blob, Empirical Software Engineering, Indexes, maintenance tasks, NASA, NASA task load index, Program Comprehension, Program Maintenance, recurring design problems, spaghetti code, Spaghetti Code, Time measurement},
	pages = {181--190},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\Charles\\Zotero\\storage\\4ASRU55D\\5741260.html:text/html;IEEE Xplore Full Text PDF:C\:\\Users\\Charles\\Zotero\\storage\\EHQRG747\\Abbes et al. - 2011 - An Empirical Study of the Impact of Two Antipatter.pdf:application/pdf}
}

@inproceedings{nakagawa_quantifying_2014,
	address = {Hyderabad, India},
	title = {Quantifying programmers' mental workload during program comprehension based on cerebral blood flow measurement: a controlled experiment},
	isbn = {978-1-4503-2768-8},
	shorttitle = {Quantifying programmers' mental workload during program comprehension based on cerebral blood flow measurement},
	url = {http://dl.acm.org/citation.cfm?doid=2591062.2591098},
	doi = {10.1145/2591062.2591098},
	abstract = {Program comprehension is a fundamental activity in software development that cannot be easily measured, as it is performed inside the human brain. Using a wearable Near Infra-red Spectroscopy (NIRS) device to measure cerebral blood ﬂow, this paper tries to answer the question: Can the measurement of brain blood-ﬂow quantify programmers’ mental workload during program comprehension activities? We performed a controlled experiment with 10 subjects; 8 of them showed high cerebral blood ﬂow while understanding strongly obfuscated programs (requiring high mental workload). This suggests the possibility of using NIRS to measure the mental workload of a person during software development activities.},
	language = {en},
	urldate = {2018-09-27},
	booktitle = {Companion {Proceedings} of the 36th {International} {Conference} on {Software} {Engineering} - {ICSE} {Companion} 2014},
	publisher = {ACM Press},
	author = {Nakagawa, Takao and Kamei, Yasutaka and Uwano, Hidetake and Monden, Akito and Matsumoto, Kenichi and German, Daniel M.},
	year = {2014},
	pages = {448--451},
	file = {Nakagawa et al. - 2014 - Quantifying programmers' mental workload during pr.pdf:C\:\\Users\\Charles\\Zotero\\storage\\KGLSDGLH\\Nakagawa et al. - 2014 - Quantifying programmers' mental workload during pr.pdf:application/pdf}
}

@article{spinellis_evaluating_2009,
	series = {Proceedings of the {International} {Workshop} on {Software} {Quality} and {Maintainability} ({SQM} 2008)},
	title = {Evaluating the {Quality} of {Open} {Source} {Software}},
	volume = {233},
	issn = {1571-0661},
	url = {http://www.sciencedirect.com/science/article/pii/S1571066109000632},
	doi = {10.1016/j.entcs.2009.02.058},
	abstract = {Traditionally, research on quality attributes was either kept under wraps within the organization that performed it, or carried out by outsiders using narrow, black-box techniques. The emergence of open source software has changed this picture allowing us to evaluate both software products and the processes that yield them. Thus, the software source code and the associated data stored in the version control system, the bug tracking databases, the mailing lists, and the wikis allow us to evaluate quality in a transparent way. Even better, the large number of (often competing) open source projects makes it possible to contrast the quality of comparable systems serving the same domain. Furthermore, by combining historical source code snapshots with significant events, such as bug discoveries and fixes, we can further dig into the causes and effects of problems. Here we present motivating examples, tools, and techniques that can be used to evaluate the quality of open source (and by extension also proprietary) software.},
	urldate = {2018-09-27},
	journal = {Electronic Notes in Theoretical Computer Science},
	author = {Spinellis, Diomidis and Gousios, Georgios and Karakoidas, Vassilios and Louridas, Panagiotis and Adams, Paul J. and Samoladas, Ioannis and Stamelos, Ioannis},
	month = mar,
	year = {2009},
	keywords = {open source, process quality attributes, product quality attributes},
	pages = {5--28},
	file = {ScienceDirect Full Text PDF:C\:\\Users\\Charles\\Zotero\\storage\\RXCNCQI6\\Spinellis et al. - 2009 - Evaluating the Quality of Open Source Software.pdf:application/pdf;ScienceDirect Snapshot:C\:\\Users\\Charles\\Zotero\\storage\\DPTCM3UN\\S1571066109000632.html:text/html}
}

@inproceedings{siegmund_understanding_2014,
	address = {Hyderabad, India},
	title = {Understanding understanding source code with functional magnetic resonance imaging},
	isbn = {978-1-4503-2756-5},
	url = {http://dl.acm.org/citation.cfm?doid=2568225.2568252},
	doi = {10.1145/2568225.2568252},
	language = {en},
	urldate = {2018-09-27},
	booktitle = {Proceedings of the 36th {International} {Conference} on {Software} {Engineering} - {ICSE} 2014},
	publisher = {ACM Press},
	author = {Siegmund, Janet and Kästner, Christian and Apel, Sven and Parnin, Chris and Bethmann, Anja and Leich, Thomas and Saake, Gunter and Brechmann, André},
	year = {2014},
	pages = {378--389},
	file = {Siegmund et al. - 2014 - Understanding understanding source code with funct.pdf:C\:\\Users\\Charles\\Zotero\\storage\\HBDRTMR4\\Siegmund et al. - 2014 - Understanding understanding source code with funct.pdf:application/pdf}
}

@inproceedings{posnett_simpler_2011,
	address = {Waikiki, Honolulu, HI, USA},
	title = {A simpler model of software readability},
	isbn = {978-1-4503-0574-7},
	url = {http://portal.acm.org/citation.cfm?doid=1985441.1985454},
	doi = {10.1145/1985441.1985454},
	abstract = {Software readability is a property that inﬂuences how easily a given piece of code can be read and understood. Since readability can aﬀect maintainability, quality, etc., programmers are very concerned about the readability of code. If automatic readability checkers could be built, they could be integrated into development tool-chains, and thus continually inform developers about the readability level of the code. Unfortunately, readability is a subjective code property, and not amenable to direct automated measurement. In a recently published study, Buse et al. asked 100 participants to rate code snippets by readability, yielding arguably reliable mean readability scores of each snippet; they then built a fairly complex predictive model for these mean scores using a large, diverse set of directly measurable source code properties. We build on this work: we present a simple, intuitive theory of readability, based on size and code entropy, and show how this theory leads to a much sparser, yet statistically signiﬁcant, model of the mean readability scores produced in Buse’s studies. Our model uses well-known size metrics and Halstead metrics, which are easily extracted using a variety of tools. We argue that this approach provides a more theoretically well-founded, practically usable, approach to readability measurement.},
	language = {en},
	urldate = {2018-09-27},
	booktitle = {Proceeding of the 8th working conference on {Mining} software repositories - {MSR} '11},
	publisher = {ACM Press},
	author = {Posnett, Daryl and Hindle, Abram and Devanbu, Premkumar},
	year = {2011},
	pages = {73},
	file = {Posnett et al. - 2011 - A simpler model of software readability.pdf:C\:\\Users\\Charles\\Zotero\\storage\\HMD67G26\\Posnett et al. - 2011 - A simpler model of software readability.pdf:application/pdf}
}

@inproceedings{butler_relating_2009,
	title = {Relating identifier naming flaws and code quality: {An} empirical study},
	shorttitle = {Relating identifier naming flaws and code quality},
	booktitle = {Reverse {Engineering}, 2009. {WCRE}'09. 16th {Working} {Conference} on},
	publisher = {IEEE},
	author = {Butler, Simon and Wermelinger, Michel and Yu, Yijun and Sharp, Helen},
	year = {2009},
	pages = {31--35},
	file = {Fulltext:C\:\\Users\\Charles\\Zotero\\storage\\ZJMAHVWP\\Butler et al. - 2009 - Relating identifier naming flaws and code quality.pdf:application/pdf;Snapshot:C\:\\Users\\Charles\\Zotero\\storage\\IXVY44T9\\5328661.html:text/html}
}

@article{buse_learning_2010,
	title = {Learning a metric for code readability},
	volume = {36},
	number = {4},
	journal = {IEEE Transactions on Software Engineering},
	author = {Buse, Raymond PL and Weimer, Westley R.},
	year = {2010},
	pages = {546--558},
	file = {Fulltext:C\:\\Users\\Charles\\Zotero\\storage\\8R7DL7JM\\Buse and Weimer - 2010 - Learning a metric for code readability.pdf:application/pdf;Snapshot:C\:\\Users\\Charles\\Zotero\\storage\\8PTCMXRJ\\5332232.html:text/html}
}

@inproceedings{butler_exploring_2010,
	title = {Exploring the influence of identifier names on code quality: {An} empirical study},
	shorttitle = {Exploring the influence of identifier names on code quality},
	booktitle = {Software {Maintenance} and {Reengineering} ({CSMR}), 2010 14th {European} {Conference} on},
	publisher = {IEEE},
	author = {Butler, Simon and Wermelinger, Michel and Yu, Yijun and Sharp, Helen},
	year = {2010},
	pages = {156--165},
	file = {Fulltext:C\:\\Users\\Charles\\Zotero\\storage\\7CYPZX3P\\Butler et al. - 2010 - Exploring the influence of identifier names on cod.pdf:application/pdf;Snapshot:C\:\\Users\\Charles\\Zotero\\storage\\2Q3V6B47\\5714430.html:text/html}
}

@inproceedings{smit_code_2011,
	title = {Code convention adherence in evolving software},
	booktitle = {Software {Maintenance} ({ICSM}), 2011 27th {IEEE} {International} {Conference} on},
	publisher = {IEEE},
	author = {Smit, Michael and Gergel, Barry and Hoover, H. James and Stroulia, Eleni},
	year = {2011},
	pages = {504--507},
	file = {Snapshot:C\:\\Users\\Charles\\Zotero\\storage\\4DAI5RG4\\6080819.html:text/html}
}

@inproceedings{wang_automatic_2011,
	title = {Automatic segmentation of method code into meaningful blocks to improve readability},
	booktitle = {Reverse {Engineering} ({WCRE}), 2011 18th {Working} {Conference} on},
	publisher = {IEEE},
	author = {Wang, Xiaoran and Pollock, Lori and Vijay-Shanker, K.},
	year = {2011},
	pages = {35--44},
	file = {Fulltext:C\:\\Users\\Charles\\Zotero\\storage\\HCSRI5IW\\Wang et al. - 2011 - Automatic segmentation of method code into meaning.pdf:application/pdf;Snapshot:C\:\\Users\\Charles\\Zotero\\storage\\KHBXFY7Z\\6079773.html:text/html}
}

@inproceedings{relf_tool_2005,
	title = {Tool assisted identifier naming for improved software readability: an empirical study},
	shorttitle = {Tool assisted identifier naming for improved software readability},
	doi = {10.1109/ISESE.2005.1541814},
	abstract = {This paper describes an empirical study investigating whether programmers improve the readability of their source code if they have support from a source code editor that offers dynamic feedback on their identifier naming practices. An experiment, employing both students and professional software engineers, and requiring the maintenance and production of software, demonstrated a statistically significant improvement in source code readability over that of the control.},
	booktitle = {2005 {International} {Symposium} on {Empirical} {Software} {Engineering}, 2005.},
	author = {Relf, P. A.},
	month = nov,
	year = {2005},
	keywords = {Software tools, software maintenance, statistical analysis, software engineering, Programming profession, Software maintenance, Australia, Costs, Cultural differences, dynamic feedback, empirical analysis, Feedback, Guidelines, Production, software production, software readability, source code editor, source code readability, tool assisted identifier naming, Writing},
	pages = {10 pp.--},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\Charles\\Zotero\\storage\\4PQX5V6U\\1541814.html:text/html;IEEE Xplore Full Text PDF:C\:\\Users\\Charles\\Zotero\\storage\\GL3SBTKV\\Relf - 2005 - Tool assisted identifier naming for improved softw.pdf:application/pdf}
}

@article{zokaites_writing_2002,
	title = {Writing understandable code},
	volume = {10},
	number = {1},
	journal = {SOFTWARE DEVELOPMENT-SAN FRANCISCO-},
	author = {Zokaites, David Michael},
	year = {2002},
	pages = {48--50},
	file = {Fulltext:C\:\\Users\\Charles\\Zotero\\storage\\T7ACIX45\\Zokaites - 2002 - Writing understandable code.pdf:application/pdf;Snapshot:C\:\\Users\\Charles\\Zotero\\storage\\F8E8FBMC\\Zokaites - 2002 - Writing understandable code.pdf:application/pdf}
}

@article{dambros_evaluating_2012,
	title = {Evaluating defect prediction approaches: a benchmark and an extensive comparison},
	volume = {17},
	shorttitle = {Evaluating defect prediction approaches},
	number = {4-5},
	journal = {Empirical Software Engineering},
	author = {D’Ambros, Marco and Lanza, Michele and Robbes, Romain},
	year = {2012},
	pages = {531--577},
	file = {Fulltext:C\:\\Users\\Charles\\Zotero\\storage\\WJVNZEB5\\D’Ambros et al. - 2012 - Evaluating defect prediction approaches a benchma.pdf:application/pdf;Snapshot:C\:\\Users\\Charles\\Zotero\\storage\\YJRIBMHB\\s10664-011-9173-9.html:text/html}
}

@misc{weinberger_google_2011,
	title = {Google {C}++ {Style} {Guide}},
	url = {http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml},
	language = {en},
	journal = {Google C++ Style Guide},
	author = {Weinberger, Benjy and Silverstein, Craig and Eitzmann, Gregory and Mentovai, Mark and Landray, Tashana},
	month = mar,
	year = {2011},
	file = {Hang et al. - Google C++ Style Guide.pdf:C\:\\Users\\Charles\\Zotero\\storage\\5TRCV8QW\\Hang et al. - Google C++ Style Guide.pdf:application/pdf}
}

@article{doland_c_1994,
	title = {C style guide ({NASA})},
	journal = {Software Engineering Laboratory Series},
	author = {Doland, Jerry and Valett, Jon},
	year = {1994},
	file = {Fulltext:C\:\\Users\\Charles\\Zotero\\storage\\6AKYL8BX\\Doland and Valett - 1994 - C style guide.pdf:application/pdf;Snapshot:C\:\\Users\\Charles\\Zotero\\storage\\BDTBQ9GD\\search.html:text/html}
}

@misc{torvalds_linux_nodate,
	title = {Linux kernel coding style},
	language = {en},
	author = {Torvalds, Linus},
	file = {Torvalds - Linux kernel coding style.pdf:C\:\\Users\\Charles\\Zotero\\storage\\XD5P8CXH\\Torvalds - Linux kernel coding style.pdf:application/pdf}
}

@misc{wroblewski_general_2002,
	title = {General {Method} of {Program} {Code} {Obfuscation}},
	abstract = {vii},
	author = {Wroblewski, Gregory},
	year = {2002},
	file = {Citeseer - Full Text PDF:C\:\\Users\\Charles\\Zotero\\storage\\G4UKR3JH\\Wroblewski - 2002 - General Method of Program Code Obfuscation.pdf:application/pdf;Citeseer - Snapshot:C\:\\Users\\Charles\\Zotero\\storage\\LQYDAUKC\\summary.html:text/html}
}

@inproceedings{gafurov_formal_2003,
	title = {Formal description of the cognitive comprehension process},
	volume = {2},
	doi = {10.1109/CCECE.2003.1226126},
	abstract = {The term of comprehension and the reveal of its mechanism and process are important research topics in cognitive informatics. Although knowledge and information are powerful, before any information can be possessed and processed, it should be comprehended properly. This paper intends to model one of the cognitive life functions, comprehension in cognitive informatics. The mechanism and process of comprehension are described based on the cognitive model of the brain developed by Wang. Then, real-time process algebra (RTPA) is used to formally describe the comprehension process. This work is considered as a fundamental facet of cognitive informatics towards the development of new theories and technologies in computing, software engineering, and life sciences.},
	booktitle = {{CCECE} 2003 - {Canadian} {Conference} on {Electrical} and {Computer} {Engineering}. {Toward} a {Caring} and {Humane} {Technology} ({Cat}. {No}.03CH37436)},
	author = {Gafurov, D. and Wang, Yingxu},
	month = may,
	year = {2003},
	keywords = {Software engineering, software engineering, cognitive systems, Algebra, artificial intelligence, Artificial intelligence, Brain modeling, brain models, Cognitive informatics, cognitive informatics real-time process algebra, comprehension process, Drives, Humans, knowledge engineering, Knowledge engineering, life sciences, Machine intelligence, process algebra, Psychology, RTPA, software computing},
	pages = {1251--1254 vol.2},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\Charles\\Zotero\\storage\\S4RLRG6X\\1226126.html:text/html;IEEE Xplore Full Text PDF:C\:\\Users\\Charles\\Zotero\\storage\\23TH2KEX\\Gafurov and Wang - 2003 - Formal description of the cognitive comprehension .pdf:application/pdf}
}

@misc{google_google_2011,
	title = {Google {Java} {Style} {Guide}},
	url = {http://google.github.io/styleguide/javaguide.html#s5-naming},
	abstract = {Style guide for Google open-source projects.},
	urldate = {2018-10-13},
	journal = {Google Java Style Guide},
	author = {{Google}},
	month = mar,
	year = {2011},
	file = {Google Java Style Guide:C\:\\Users\\Charles\\Zotero\\storage\\ICMDAUWL\\javaguide.html:text/html}
}

@misc{van_rossum_pythonstyle-pep_2001,
	title = {{PythonStyle}-{PEP} 8 - {Style} {Guide} for {Python} {Code} \_ {Python}.pdf},
	url = {http://downloads.niceware.com/TECH-pdf/PythonStyle-PEP%208%20-%20Style%20Guide%20for%20Python%20Code%20_%20Python.pdf},
	abstract = {Python Style Guide},
	urldate = {2018-09-27},
	author = {Van Rossum, Guido and Warsaw, Barry and Coghlan, Nick},
	month = jul,
	year = {2001},
	file = {PythonStyle-PEP 8 - Style Guide for Python Code _ Python.pdf:C\:\\Users\\Charles\\Zotero\\storage\\QY3IKC7M\\PythonStyle-PEP 8 - Style Guide for Python Code _ Python.pdf:application/pdf}
}

@article{feigenspan_background_2013,
	title = {Do background colors improve program comprehension in the \#ifdef hell?},
	volume = {18},
	issn = {1382-3256, 1573-7616},
	url = {http://link.springer.com/10.1007/s10664-012-9208-x},
	doi = {10.1007/s10664-012-9208-x},
	language = {en},
	number = {4},
	urldate = {2018-10-14},
	journal = {Empirical Software Engineering},
	author = {Feigenspan, Janet and Kästner, Christian and Apel, Sven and Liebig, Jörg and Schulze, Michael and Dachselt, Raimund and Papendieck, Maria and Leich, Thomas and Saake, Gunter},
	month = aug,
	year = {2013},
	pages = {699--745},
	file = {Feigenspan et al. - 2013 - Do background colors improve program comprehension.pdf:C\:\\Users\\Charles\\Zotero\\storage\\KTKU829Z\\Feigenspan et al. - 2013 - Do background colors improve program comprehension.pdf:application/pdf}
}

@inproceedings{gale_collaborative_1996,
	address = {Vancouver, British Columbia, Canada},
	title = {A collaborative approach to developing style guides},
	isbn = {978-0-89791-777-3},
	url = {http://portal.acm.org/citation.cfm?doid=238386.238572},
	doi = {10.1145/238386.238572},
	abstract = {A vital element in exploiting the benefits of Graphical User Interfaces (GUIs) is the use of an appropriate Style Guide. This paper outlines a collaborative approach to the development of Style Guides and highlights the associated benefits and pitfalls.},
	language = {en},
	urldate = {2018-10-14},
	booktitle = {Proceedings of the {SIGCHI} conference on {Human} factors in computing systems common ground - {CHI} '96},
	publisher = {ACM Press},
	author = {Gale, Stephen},
	year = {1996},
	pages = {362--367},
	file = {Gale - 1996 - A collaborative approach to developing style guide.pdf:C\:\\Users\\Charles\\Zotero\\storage\\C5NJH6TY\\Gale - 1996 - A collaborative approach to developing style guide.pdf:application/pdf}
}

@misc{noauthor_pdf_nodate,
	title = {({PDF}) {An} introduction to program comprehension for computer science educators},
	url = {https://www.researchgate.net/publication/229681961_An_introduction_to_program_comprehension_for_computer_science_educators},
	abstract = {PDF {\textbar} The area of program comprehension comprises a vast body of literature, with numerous conflicting models having been proposed. Models are typically grounded in experimental studies mostly involving experienced programmers. The question of how to relate this material to the...},
	language = {en},
	urldate = {2018-10-14},
	journal = {ResearchGate},
	doi = {http://dx.doi.org/10.1145/1971681.1971687},
	file = {Snapshot:C\:\\Users\\Charles\\Zotero\\storage\\9IFNFVL9\\229681961_An_introduction_to_program_comprehension_for_computer_science_educators.html:text/html}
}

@book{mcconnell_code_2004,
	title = {Code {Complete}},
	isbn = {978-0-7356-1967-8},
	abstract = {For more than a decade, Steve McConnell has helped change the way developers write code - and produce better software. Now his book, 'Code Complete', has been fully updated and revised with best practices in the art and science of constructing software. Whether you're a new developer seeking a sound introduction to the practice of software development or a veteran exploring strategic new approaches to problem solving, you'll find practical suggestions and methods for strengthening your skills. Topics include design, applying good techniques to construction, eliminating errors, planning, managing construction activities, and relating personal character to superior software. You'll find new code examples in C++, Microsoft(r) Visual Basic(r), C\#, and Java, though the focus is squarely on techniques and practices.},
	language = {en},
	publisher = {Pearson Education},
	author = {McConnell, Steve},
	year = {2004},
	note = {Google-Books-ID: pDsFCAAAQBAJ},
	keywords = {Computers / Software Development \& Engineering / General}
}

@inproceedings{storey_theories_2005,
	title = {Theories, methods and tools in program comprehension: past, present and future},
	shorttitle = {Theories, methods and tools in program comprehension},
	doi = {10.1109/WPC.2005.38},
	abstract = {Program comprehension research can be characterized by both the theories that provide rich explanations about how programmers comprehend software, as well as the tools that are used to assist in comprehension tasks. During this talk the author review some of the key cognitive theories of program comprehension that have emerged. Using these theories as a canvas, the author then explores how tools that are popular today have evolved to support program comprehension. Specifically, the author discusses how the theories and tools are related and reflect on the research methods that were used to construct the theories and evaluate the tools. The reviewed theories and tools will be further differentiated according to human characteristics, program characteristics, and the context for the various comprehension tasks. Finally, the author predicts how these characteristics will change in the future and speculate on how a number of important research directions could lead to improvements in program comprehension tools and methods.},
	booktitle = {13th {International} {Workshop} on {Program} {Comprehension} ({IWPC}'05)},
	author = {Storey, M.-},
	month = may,
	year = {2005},
	keywords = {Software tools, Software engineering, reverse engineering, Programming profession, Computer science, Humans, Buildings, cognition, Conferences, Electronic mail, History, human characteristics, program characteristics, program comprehension tools, Silver, software tools},
	pages = {181--191},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\Charles\\Zotero\\storage\\KSY9NK2M\\1421034.html:text/html;IEEE Xplore Full Text PDF:C\:\\Users\\Charles\\Zotero\\storage\\E39GB8B3\\Storey - 2005 - Theories, methods and tools in program comprehensi.pdf:application/pdf}
}

@misc{noauthor_conceptual_nodate,
	title = {Conceptual {Architecture} of the {Linux} {Kernel}},
	url = {https://docs.huihoo.com/linux/kernel/a1/index.html},
	urldate = {2018-10-18},
	file = {Conceptual Architecture of the Linux Kernel:C\:\\Users\\Charles\\Zotero\\storage\\TNXX4Q9Z\\index.html:text/html}
}

@misc{ward_program_nodate,
	address = {De Montfort University},
	type = {Reader in {Software} {Engineering}},
	title = {Program {Comprehension}},
	author = {Ward, Martin}
}

@misc{alhindawi_degree_nodate,
	title = {degree of {Doctor} of {Philosophy}},
	language = {en},
	author = {Alhindawi, Nouh},
	file = {Alhindawi - degree of Doctor of Philosophy.pdf:C\:\\Users\\Charles\\Zotero\\storage\\P2ZUSMYR\\Alhindawi - degree of Doctor of Philosophy.pdf:application/pdf}
}

@misc{sherman_21_nodate,
	title = {21 dangerous pieces of code and programming missteps},
	url = {https://techbeacon.com/21-dangerous-pieces-of-code-and-programming-missteps},
	abstract = {Here are some of the most destructive examples of code, from security vulnerabilities to nasty bugs. Just a missed semicolon or an unnecessary...},
	language = {en},
	urldate = {2018-10-20},
	journal = {TechBeacon},
	author = {Sherman, Erik},
	file = {Snapshot:C\:\\Users\\Charles\\Zotero\\storage\\NLEKJ7KN\\21-dangerous-pieces-of-code-and-programming-missteps.html:text/html}
}

@techreport{collberg_taxonomy_1997,
	type = {Technical {Report}},
	title = {A {Taxonomy} of {Obfuscating} {Transformations}},
	copyright = {https://researchspace.auckland.ac.nz/docs/uoa-docs/rights.htm},
	url = {https://researchspace.auckland.ac.nz/handle/2292/3491},
	abstract = {It has become more and more common to distribute software in forms that retain most or all of the information present in the original source code. An important example is Java bytecode. Since such codes are easy to decompile, they increase the risk of malicious reverse engineering attacks. In this paper we review several techniques for technical protection of software secrets. We will argue that automatic code obfuscation is currently the most viable method for preventing reverse engineering. We then describe the design of a code obfuscator, a tool which converts a program into an equivalent one that is more difficult to understand and reverse engineer. The obfuscator is based on the application of code transformations, in many cases similar to those used by complier optimizers. We describe a large number of such transformations, classify them, and evaluated them with respect to their potency (to what degree is a human reader confused?), resilience (how well are automatic deobfuscation attacks resisted?), and cost (how much overhead is added to the application?). We finally discuss some possible deobfuscation techniques (such as program slicing) and possible countermeasures an obfuscator could employ against them.},
	urldate = {2018-10-21},
	institution = {Department of Computer Science, The University of Auckland, New Zealand},
	author = {Collberg, Christian and Thomborson, C. and Low, Douglas},
	month = jul,
	year = {1997},
	file = {Snapshot:C\:\\Users\\Charles\\Zotero\\storage\\GC4TNNTA\\3491.html:text/html}
}

@article{maurya_software_nodate,
	title = {Software {Readability} {Metric}},
	abstract = {Software products are costly as compare to hardware. And developing software products at nominal cost are always a big issue for project managers. Therefore they desperately look for way-outs to cut development cost. While developing Software, its quality has become essential from the client point of view. So, Software understandability is vital and one of the most significant components of the software quality. The lack of understandability aspect often leads to false interpretation that may in turn lead to ambiguities, misunderstanding and hence to faulty development results. It plays an important role as far as the issue of delivering quality software is concerned. Therefore, Understandability is obviously relevant and significant in software maintenance. Software metrics can be derived using Class Inheritance Directed Acyclic Graph(CIDAG) approach to measure the understandability. In our approach as DIT is combined with predecessor and successor of class, the values of understandability metrics are higher in comparisons to existing approach. Our approach proposes a metrics for understandability measurement based on class inheritance, in an efficient way.},
	language = {en},
	journal = {International Journal of Computer Applications},
	author = {Maurya, Anamika},
	pages = {5},
	file = {Maurya - Software Readability Metric.pdf:C\:\\Users\\Charles\\Zotero\\storage\\85EHPDBU\\Maurya - Software Readability Metric.pdf:application/pdf}
}

@article{letovsky_cognitive_1987,
	title = {Cognitive processes in program comprehension},
	volume = {7},
	issn = {0164-1212},
	url = {http://www.sciencedirect.com/science/article/pii/016412128790032X},
	doi = {10.1016/0164-1212(87)90032-X},
	abstract = {This paper reports on an empirical study of the cognitive processes involved in program comprehension. Verbal protocols were gathered from professional programmers as they were engaged in a program-understanding task. Based on analysis of these protocols, several types of interesting cognitive events were identified. These include asking questions and conjecturing facts about the code. We describe these event types and use them to derive a computational model of the programmers' mental processes.},
	number = {4},
	urldate = {2018-10-22},
	journal = {Journal of Systems and Software},
	author = {Letovsky, Stanley},
	month = dec,
	year = {1987},
	pages = {325--339},
	file = {ScienceDirect Snapshot:C\:\\Users\\Charles\\Zotero\\storage\\BA7T9XRQ\\016412128790032X.html:text/html}
}

@inproceedings{buse_metric_2008,
	address = {Seattle, WA, USA},
	title = {A metric for software readability},
	isbn = {978-1-60558-050-0},
	url = {http://portal.acm.org/citation.cfm?doid=1390630.1390647},
	doi = {10.1145/1390630.1390647},
	abstract = {In this paper, we explore the concept of code readability and investigate its relation to software quality. With data collected from human annotators, we derive associations between a simple set of local code features and human notions of readability. Using those features, we construct an automated readability measure and show that it can be 80\% eﬀective, and better than a human on average, at predicting readability judgments. Furthermore, we show that this metric correlates strongly with two traditional measures of software quality, code changes and defect reports. Finally, we discuss the implications of this study on programming language design and engineering practice. For example, our data suggests that comments, in of themselves, are less important than simple blank lines to local judgments of readability.},
	language = {en},
	urldate = {2018-10-22},
	booktitle = {Proceedings of the 2008 international symposium on {Software} testing and analysis - {ISSTA} '08},
	publisher = {ACM Press},
	author = {Buse, Raymond P.L. and Weimer, Westley R.},
	year = {2008},
	pages = {121},
	file = {Buse and Weimer - 2008 - A metric for software readability.pdf:C\:\\Users\\Charles\\Zotero\\storage\\MYZYN3SI\\Buse and Weimer - 2008 - A metric for software readability.pdf:application/pdf}
}

@article{dorn_general_nodate,
	title = {A {General} {Software} {Readability} {Model}},
	abstract = {We present a generalizable formal model of software readability based on a human study of 5000 participants. Readability is fundamental to maintenance, but remains poorly understood. Previous models focused on symbol counts of small code snippets. By contrast, we approach code as read on screens by humans and propose to analyze visual, spatial and linguistic features, including structural patterns, sizes of code blocks, and verbal identiﬁer content. We construct a readability metric based on these notions and show that it agrees with human judgments as well as they agree with each other and better than previous work. We identify universal features of readability and languageor experience-speciﬁc ones. Our metric also correlates with an external notion of defect density. We address multiple programming languages and different length samples, and evaluate using an order of magnitude more participants than previous work, all suggesting our model is more likely to generalize.},
	language = {en},
	author = {Dorn, Jonathan},
	pages = {13},
	file = {Dorn - A General Software Readability Model.pdf:C\:\\Users\\Charles\\Zotero\\storage\\BM62JUNA\\Dorn - A General Software Readability Model.pdf:application/pdf}
}

@misc{angosto_pdf_nodate,
	title = {({PDF}) {Evidence} for {Top}-{Down} {Processing} in {Reading} {Comprehension} of {Children}},
	url = {https://www.researchgate.net/publication/263508605_Evidence_for_Top-Down_Processing_in_Reading_Comprehension_of_Children},
	abstract = {PDF {\textbar} El presente estudio aborda la problemática de los modelos de procesamiento de la lectura actualmente vigentes en la Psicología, donde existe un dualismo entre los modelos de procesamiento de abajo-arriba, ampliamente estudiados, y los modelos de procesamiento de arriba-abajo,...},
	language = {en},
	urldate = {2018-11-21},
	journal = {ResearchGate},
	author = {Angosto, Alberto and Alvarez, Maria and Sanchez, Patricia and Cuevas, Irene},
	doi = {http://dx.doi.org/10.1016/S1135-755X(13)70014-9},
	file = {Full Text:C\:\\Users\\Charles\\Zotero\\storage\\2YD9JVYC\\(PDF) Evidence for Top-Down Processing in Reading .pdf:application/pdf;Snapshot:C\:\\Users\\Charles\\Zotero\\storage\\B55UVWMT\\263508605_Evidence_for_Top-Down_Processing_in_Reading_Comprehension_of_Children.html:text/html}
}

@misc{noauthor_international_nodate,
	title = {The {International} {Obfuscated} {C} {Code} {Contest}},
	url = {https://www.ioccc.org/},
	urldate = {2018-11-21},
	file = {The International Obfuscated C Code Contest:C\:\\Users\\Charles\\Zotero\\storage\\M2WQX7UV\\www.ioccc.org.html:text/html}
}